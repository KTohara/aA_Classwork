quit
game
pry
game.win_row?(:O)
game = Board.new
game = Game.new
# p game.empty_positions?
# game.win?(:O)
# game.win_diagonal?(:O)
# game.win_col?(:O)
# game.win_row?(:O)
# game.printboard
# print game.grid[0], "\n", game.grid[1], "\n", game.grid[2], "\n"
# game.place_mark([1,4], ":X")
# game.place_mark([0,2], :O)
# game.place_mark([0,1], :O)
# game.place_mark([0,0], :O)
# row
# game.place_mark([2,0], :O)
# game.place_mark([1,0], :O)
# game.place_mark([0,0], :O)
# col
# game.place_mark([2,0], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,2], :O)
# diagonal
# game.place_mark([2,2], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,0], :O)
# diagonal
# game.grid
            return true
            puts "Player with #{mark} wins!"
         if row.count(mark) == @grid[0].length
      new_grid.each do |row|
      new_grid = @grid.transpose
      # end
      #    end
      #       new_grid[j] << grid[i][j]
      #    (0...col).each do |j|
      # (0...row).each do |i|
      # new_grid = Array.new(row) { [] * col }
      # col = @grid.length
      # row = @grid[0].length
   def win_col?(mark) 
   end
      end
         false
         end
            return true
            puts "Player with #{mark} wins!"
         if row.count(mark) == @grid[0].length
      @grid.each do |row|
   def win_row?(mark)
   end
      @grid.each { |row| puts row.join(" ") }
   def printboard
   end
      self[pos] = mark
      raise "#{pos} is not a valid spot!" if !valid?(pos) || !empty?(pos)
   def place_mark(pos, mark)
   end
      self[pos] == '_'
      debugger
   def empty?(pos)
   end
      end
         0 <= i && i < @grid.length
      pos.all? do |i|
      # @grid[i][j] != nil
      # j = pos[1]
      # i = pos[0]
   def valid?(pos) # ie [1, 4]
   end
      @grid[row][col] = val
      row, col = pos
   def []=(pos, val)
   end
      @grid[row][col]
      row, col = pos
   def [](pos)
   end
      @grid = Array.new(3) { ['_'] * 3 }
   def initialize
class Board
require 'byebug'
game.win_row?(:O)
game
game = Board.new
end
# p game.empty_positions?
# game.win?(:O)
# game.win_diagonal?(:O)
# game.win_col?(:O)
# game.win_row?(:O)
# game.printboard
# print game.grid[0], "\n", game.grid[1], "\n", game.grid[2], "\n"
# game.place_mark([1,4], ":X")
# game.place_mark([0,2], :O)
# game.place_mark([0,1], :O)
# game.place_mark([0,0], :O)
# row
# game.place_mark([2,0], :O)
# game.place_mark([1,0], :O)
# game.place_mark([0,0], :O)
# col
# game.place_mark([2,0], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,2], :O)
# diagonal
# game.place_mark([2,2], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,0], :O)
# diagonal
# game.grid
p game.empty?([1,2])
game = Board.new
# Pry.toplevel_binding.eval File.read("board.rb")
end
   # end
   #    count == 0 ? true : false
   #    end
   #       row.each { |el| count += 1 if el == "_" }
   #    @grid.each do |row|
   #    count = 0
   # def empty_positions?
   # end
   #    false
   #    end
   #       return true 
   #    if win_diagonal?(mark) || win_row?(mark) || win_col?(mark)
   # def win?(mark)
   # end
   #    end
   #       return true
   #       puts "Player with #{mark} wins!"
   #    if transpose_count == @grid.length
   #    end
   #       end
   #          transpose_count += 1 if i == j && new_grid[i][j] == mark
   #       new_grid[0].each_index do |j|
   #    new_grid.each_index do |i|
   #    new_grid = @grid.transpose
   #    transpose_count = 0
   #    # win diagonal other way
   #    end
   #       return true
   #       puts "Player with #{mark} wins!"
   #    if count == @grid.length
   #    end
   #       end
   #          count += 1 if i == j && @grid[i][j] == mark
   #       @grid[0].each_index do |j|
   #    @grid.each_index do |i|
   #    count = 0
   #    # win diagonal one way
   # def win_diagonal?(mark)
   # end
   #    end
   #       false
   #       end
   #          return true
   #          puts "Player with #{mark} wins!"
   #       if row.count(mark) == @grid[0].length
   #    new_grid.each do |row|
   #    new_grid = @grid.transpose
   #    # end
   #    #    end
   #    #       new_grid[j] << grid[i][j]
   #    #    (0...col).each do |j|
   #    # (0...row).each do |i|
   #    # new_grid = Array.new(row) { [] * col }
   #    # col = @grid.length
   #    # row = @grid[0].length
   # def win_col?(mark) 
   end
      end
         false
         end
            return true
            puts "Player with #{mark} wins!"
         if row.count(mark) == @grid[0].length
      @grid.any? do |row|
   def win_row?(mark)
   end
      @grid.each { |row| puts row.join(" ") }
   def printboard
   end
      self[pos] = mark
      raise "#{pos} is not a valid spot!" if !valid?(pos) || !empty?(pos)
   def place_mark(pos, mark)
   end
      self[pos] == '_'
      debugger
   def empty?(pos)
   end
      end
         0 <= i && i < @grid.length
      pos.all? do |i|
      # @grid[i][j] != nil
      # j = pos[1]
      # i = pos[0]
   def valid?(pos) # ie [1, 4]
   end
      @grid[row][col] = val
      row, col = pos
   def []=(pos, val)
   end
      @grid[row][col]
      row, col = pos
   def [](pos)
   end
      @grid = Array.new(3) { ['_'] * 3 }
   def initialize
class Board
require 'byebug'
game.win_row?(:O)
game
game = Board.new
# p game.empty_positions?
# game.win?(:O)
# game.win_diagonal?(:O)
# game.win_col?(:O)
# game.win_row?(:O)
# game.printboard
# print game.grid[0], "\n", game.grid[1], "\n", game.grid[2], "\n"
# game.place_mark([1,4], ":X")
# game.place_mark([0,2], :O)
# game.place_mark([0,1], :O)
# game.place_mark([0,0], :O)
# row
# game.place_mark([2,0], :O)
# game.place_mark([1,0], :O)
# game.place_mark([0,0], :O)
# col
# game.place_mark([2,0], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,2], :O)
# diagonal
# game.place_mark([2,2], :O)
# game.place_mark([1,1], :O)
# game.place_mark([0,0], :O)
# diagonal
# game.grid
            return true
            puts "Player with #{mark} wins!"
         if row.count(mark) == @grid[0].length
      new_grid.each do |row|
      new_grid = @grid.transpose
      # end
      #    end
      #       new_grid[j] << grid[i][j]
      #    (0...col).each do |j|
      # (0...row).each do |i|
      # new_grid = Array.new(row) { [] * col }
      # col = @grid.length
